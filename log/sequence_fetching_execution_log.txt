[NbConvertApp] Converting notebook sequence_fetching.ipynb to notebook

Traceback (most recent call last):
  File "/Applications/anaconda3/bin/jupyter-nbconvert", line 11, in <module>
    sys.exit(main())
             ^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/jupyter_core/application.py", line 277, in launch_instance
    return super().launch_instance(argv=argv, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/traitlets/config/application.py", line 992, in launch_instance
object address  : 0x10fae2e00
object refcount : 4
object type     : 0x10111daf0
object type name: KeyboardInterrupt
object repr     : KeyboardInterrupt()
lost sys.stderr
Task exception was never retrieved
future: <Task finished name='Task-57' coro=<NotebookClient.async_execute_cell() done, defined at /Applications/anaconda3/lib/python3.11/site-packages/nbclient/client.py:864> exception=CellExecutionError('An error occurred while executing the following cell:\n------------------\ngene_info <- gene_info %>%\n  mutate(upstream_region <-  pmap_chr(\n      list(chromosome_name, upstream_start, upstream_end, strand), \n      fetch_sequence\n  ))\n------------------\n\n\x1b[1m\x1b[33mError\x1b[39m in `mutate()`:\x1b[22m\n\x1b[1m\x1b[22m\x1b[36mℹ\x1b[39m In argument: `... <- NULL`.\n\x1b[1mCaused by error in `pmap_chr()`:\x1b[22m\n\x1b[1m\x1b[22m\x1b[36mℹ\x1b[39m In index: 5174.\n\x1b[1mCaused by error in `curl::curl_fetch_memory()`:\x1b[22m\n\x1b[33m!\x1b[39m Operation was aborted by an application callback\nTraceback:\n\n1. gene_info %>% mutate(upstream_region <- pmap_chr(list(chromosome_name, \n .     upstream_start, upstream_end, strand), fetch_sequence))\n2. mutate(., upstream_region <- pmap_chr(list(chromosome_name, upstream_start, \n .     upstream_end, strand), fetch_sequence))\n3. mutate.data.frame(., upstream_region <- pmap_chr(list(chromosome_name, \n .     upstream_start, upstream_end, strand), fetch_sequence))\n4. mutate_cols(.data, dplyr_quosures(...), by)\n5. withCallingHandlers(for (i in seq_along(dots)) {\n .     poke_error_context(dots, i, mask = mask)\n .     context_poke("column", old_current_column)\n .     new_columns <- mutate_col(dots[[i]], data, mask, new_columns)\n . }, error = dplyr_error_handler(dots = dots, mask = mask, bullets = mutate_bullets, \n .     error_call = error_call, error_class = "dplyr:::mutate_error"), \n .     warning = dplyr_warning_handler(state = warnings_state, mask = mask, \n .         error_call = error_call))\n6. mutate_col(dots[[i]], data, mask, new_columns)\n7. mask$eval_all_mutate(quo)\n8. eval()\n9. pmap_chr(list(chromosome_name, upstream_start, upstream_end, \n .     strand), fetch_sequence)\n10. pmap_("character", .l, .f, ..., .progress = .progress)\n11. with_indexed_errors(i = i, names = names, error_call = .purrr_error_call, \n  .     call_with_cleanup(pmap_impl, environment(), .type, .progress, \n  .         n, names, i, call_names, call_n))\n12. withCallingHandlers(expr, error = function(cnd) {\n  .     if (i == 0L) {\n  .     }\n  .     else {\n  .         message <- c(i = "In index: {i}.")\n  .         if (!is.null(names) && !is.na(names[[i]]) && names[[i]] != \n  .             "") {\n  .             name <- names[[i]]\n  .             message <- c(message, i = "With name: {name}.")\n  .         }\n  .         else {\n  .             name <- NULL\n  .         }\n  .         cli::cli_abort(message, location = i, name = name, parent = cnd, \n  .             call = error_call, class = "purrr_error_indexed")\n  .     }\n  . })\n13. call_with_cleanup(pmap_impl, environment(), .type, .progress, \n  .     n, names, i, call_names, call_n)\n14. .f(.l[[1L]][[i]], .l[[2L]][[i]], .l[[3L]][[i]], .l[[4L]][[i]], \n  .     ...)\n15. GET(paste0(server, ext), content_type("text/plain"))   # at line 4 of file <text>\n16. request_perform(req, hu$handle$handle)\n17. request_fetch(req$output, req$url, handle)\n18. request_fetch.write_memory(req$output, req$url, handle)\n19. curl::curl_fetch_memory(url, handle = handle)\n20. .handleSimpleError(function (cnd) \n  . {\n  .     if (i == 0L) {\n  .     }\n  .     else {\n  .         message <- c(i = "In index: {i}.")\n  .         if (!is.null(names) && !is.na(names[[i]]) && names[[i]] != \n  .             "") {\n  .             name <- names[[i]]\n  .             message <- c(message, i = "With name: {name}.")\n  .         }\n  .         else {\n  .             name <- NULL\n  .         }\n  .         cli::cli_abort(message, location = i, name = name, parent = cnd, \n  .             call = error_call, class = "purrr_error_indexed")\n  .     }\n  . }, "Operation was aborted by an application callback", base::quote(curl::curl_fetch_memory(url, \n  .     handle = handle)))\n21. h(simpleError(msg, call))\n22. cli::cli_abort(message, location = i, name = name, parent = cnd, \n  .     call = error_call, class = "purrr_error_indexed")\n23. rlang::abort(message, ..., call = call, use_cli_format = TRUE, \n  .     .frame = .frame)\n24. signal_abort(cnd, .file)\n25. signalCondition(cnd)\n26. (function (cnd) \n  . {\n  .     local_error_context(dots, i = frame[[i_sym]], mask = mask)\n  .     if (inherits(cnd, "dplyr:::internal_error")) {\n  .         parent <- error_cnd(message = bullets(cnd))\n  .     }\n  .     else {\n  .         parent <- cnd\n  .     }\n  .     message <- c(cnd_bullet_header(action), i = if (has_active_group_context(mask)) cnd_bullet_cur_group_label())\n  .     abort(message, class = error_class, parent = parent, call = error_call)\n  . })(structure(list(message = c(i = "In index: 5174."), trace = structure(list(\n  .     call = list(IRkernel::main(), kernel$run(), handle_shell(), \n  .         executor$execute(msg), tryCatch(evaluate(request$content$code, \n  .             envir = .GlobalEnv, output_handler = oh, stop_on_error = 1L), \n  .             interrupt = function(cond) {\n  .                 log_debug("Interrupt during execution")\n  .                 interrupted <<- TRUE\n  .             }, error = .self$handle_error), tryCatchList(expr, \n  .             classes, parentenv, handlers), tryCatchOne(tryCatchList(expr, \n  .             names[-nh], parentenv, handlers[-nh]), names[nh], \n  .             parentenv, handlers[[nh]]), doTryCatch(return(expr), \n  .             name, parentenv, handler), tryCatchList(expr, names[-nh], \n  .             parentenv, handlers[-nh]), tryCatchOne(expr, names, \n  .             parentenv, handlers[[1L]]), doTryCatch(return(expr), \n  .             name, parentenv, handler), evaluate(request$content$code, \n  .             envir = .GlobalEnv, output_handler = oh, stop_on_error = 1L), \n  .         evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, \n  .             debug = debug, last = i == length(out), use_try = stop_on_error != \n  .                 2L, keep_warning = keep_warning, keep_message = keep_message, \n  .             log_echo = log_echo, log_warning = log_warning, output_handler = output_handler, \n  .             include_timing = include_timing), timing_fn(handle(ev <- withCallingHandlers(withVisible(eval_with_user_handlers(expr, \n  .             envir, enclos, user_handlers)), warning = wHandler, \n  .             error = eHandler, message = mHandler))), handle(ev <- withCallingHandlers(withVisible(eval_with_user_handlers(expr, \n  .             envir, enclos, user_handlers)), warning = wHandler, \n  .             error = eHandler, message = mHandler)), try(f, silent = TRUE), \n  .         tryCatch(expr, error = function(e) {\n  .             call <- conditionCall(e)\n  .             if (!is.null(call)) {\n  .                 if (identical(call[[1L]], quote(doTryCatch))) \n  .                   call <- sys.call(-4L)\n  .                 dcall <- deparse(call, nlines = 1L)\n  .                 prefix <- paste("Error in", dcall, ": ")\n  .                 LONG <- 75L\n  .                 sm <- strsplit(conditionMessage(e), "\\n")[[1L]]\n  .                 w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], \n  .                   type = "w")\n  .                 if (is.na(w)) \n  .                   w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L], \n  .                     type = "b")\n  .                 if (w > LONG) \n  .                   prefix <- paste0(prefix, "\\n  ")\n  .             }\n  .             else prefix <- "Error : "\n  .             msg <- paste0(prefix, conditionMessage(e), "\\n")\n  .             .Internal(seterrmessage(msg[1L]))\n  .             if (!silent && isTRUE(getOption("show.error.messages"))) {\n  .                 cat(msg, file = outFile)\n  .                 .Internal(printDeferredWarnings())\n  .             }\n  .             invisible(structure(msg, class = "try-error", condition = e))\n  .         }), tryCatchList(expr, classes, parentenv, handlers), \n  .         tryCatchOne(expr, names, parentenv, handlers[[1L]]), \n  .         doTryCatch(return(expr), name, parentenv, handler), withCallingHandlers(withVisible(eval_with_user_handlers(expr, \n  .             envir, enclos, user_handlers)), warning = wHandler, \n  .             error = eHandler, message = mHandler), withVisible(eval_with_user_handlers(expr, \n  .             envir, enclos, user_handlers)), eval_with_user_handlers(expr, \n  .             envir, enclos, user_handlers), eval(expr, envir, \n  .             enclos), eval(expr, envir, enclos), gene_info %>% \n  .             mutate(upstream_region <- pmap_chr(list(chromosome_name, \n  .                 upstream_start, upstream_end, strand), fetch_sequence)), \n  .         mutate(., upstream_region <- pmap_chr(list(chromosome_name, \n  .             upstream_start, upstream_end, strand), fetch_sequence)), \n  .         mutate.data.frame(., upstream_region <- pmap_chr(list(chromosome_name, \n  .             upstream_start, upstream_end, strand), fetch_sequence)), \n  .         mutate_cols(.data, dplyr_quosures(...), by), withCallingHandlers(for (i in seq_along(dots)) {\n  .             poke_error_context(dots, i, mask = mask)\n  .             context_poke("column", old_current_column)\n  .             new_columns <- mutate_col(dots[[i]], data, mask, \n  .                 new_columns)\n  .         }, error = dplyr_error_handler(dots = dots, mask = mask, \n  .             bullets = mutate_bullets, error_call = error_call, \n  .             error_class = "dplyr:::mutate_error"), warning = dplyr_warning_handler(state = warnings_state, \n  .             mask = mask, error_call = error_call)), mutate_col(dots[[i]], \n  .             data, mask, new_columns), mask$eval_all_mutate(quo), \n  .         eval(), pmap_chr(list(chromosome_name, upstream_start, \n  .             upstream_end, strand), fetch_sequence), pmap_("character", \n  .             .l, .f, ..., .progress = .progress), with_indexed_errors(i = i, \n  .             names = names, error_call = .purrr_error_call, call_with_cleanup(pmap_impl, \n  .                 environment(), .type, .progress, n, names, i, \n  .                 call_names, call_n)), withCallingHandlers(expr, \n  .             error = function(cnd) {\n  .                 if (i == 0L) {\n  .                 }\n  .                 else {\n  .                   message <- c(i = "In index: {i}.")\n  .                   if (!is.null(names) && !is.na(names[[i]]) && \n  .                     names[[i]] != "") {\n  .                     name <- names[[i]]\n  .                     message <- c(message, i = "With name: {name}.")\n  .                   }\n  .                   else {\n  .                     name <- NULL\n  .                   }\n  .                   cli::cli_abort(message, location = i, name = name, \n  .                     parent = cnd, call = error_call, class = "purrr_error_indexed")\n  .                 }\n  .             }), call_with_cleanup(pmap_impl, environment(), .type, \n  .             .progress, n, names, i, call_names, call_n), .f(.l[[1L]][[i]], \n  .             .l[[2L]][[i]], .l[[3L]][[i]], .l[[4L]][[i]], ...), \n  .         GET(paste0(server, ext), content_type("text/plain")), \n  .         request_perform(req, hu$handle$handle), request_fetch(req$output, \n  .             req$url, handle), request_fetch.write_memory(req$output, \n  .             req$url, handle), curl::curl_fetch_memory(url, handle = handle), \n  .         .handleSimpleError(`<fn>`, "Operation was aborted by an application callback", \n  .             base::quote(curl::curl_fetch_memory(url, handle = handle))), \n  .         h(simpleError(msg, call)), cli::cli_abort(message, location = i, \n  .             name = name, parent = cnd, call = error_call, class = "purrr_error_indexed"), \n  .         rlang::abort(message, ..., call = call, use_cli_format = TRUE, \n  .             .frame = .frame)), parent = c(0L, 1L, 2L, 3L, 4L, \n  .     5L, 6L, 7L, 6L, 9L, 10L, 4L, 12L, 13L, 13L, 15L, 16L, 17L, \n  .     18L, 19L, 13L, 13L, 13L, 23L, 24L, 0L, 0L, 0L, 28L, 29L, \n  .     29L, 31L, 32L, 0L, 34L, 35L, 36L, 35L, 35L, 39L, 40L, 41L, \n  .     41L, 43L, 0L, 45L, 46L, 47L), visible = c(TRUE, TRUE, TRUE, \n  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, \n  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, \n  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, \n  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, \n  .     TRUE, FALSE, FALSE, FALSE, FALSE), namespace = c("IRkernel", \n  .     NA, "IRkernel", NA, "base", "base", "base", "base", "base", \n  .     "base", "base", "evaluate", "evaluate", "evaluate", "evaluate", \n  .     "base", "base", "base", "base", "base", "base", "base", "evaluate", \n  .     "base", "base", NA, "dplyr", "dplyr", "dplyr", "base", "dplyr", \n  .     NA, "dplyr", "purrr", "purrr", "purrr", "base", "purrr", \n  .     NA, "httr", "httr", "httr", "httr", "curl", "base", "purrr", \n  .     "cli", "rlang"), scope = c("::", NA, "local", NA, "::", "local", \n  .     "local", "local", "local", "local", "local", "::", ":::", \n  .     "local", "local", "::", "::", "local", "local", "local", \n  .     "::", "::", ":::", "::", "::", NA, "::", ":::", ":::", "::", \n  .     ":::", NA, "local", "::", ":::", ":::", "::", ":::", "global", \n  .     "::", ":::", ":::", ":::", "::", "::", "local", "::", "::"\n  .     ), error_frame = c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, \n  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, \n  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, \n  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, \n  .     TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, \n  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)), row.names = c(NA, \n  . -48L), version = 2L, class = c("rlang_trace", "rlib_trace", "tbl", \n  . "data.frame")), parent = structure(list(message = "Operation was aborted by an application callback", \n  .     call = curl::curl_fetch_memory(url, handle = handle)), class = c("simpleError", \n  . "error", "condition")), location = 5174L, name = NULL, rlang = list(\n  .     inherit = TRUE), call = pmap_chr(list(chromosome_name, upstream_start, \n  .     upstream_end, strand), fetch_sequence), use_cli_format = TRUE), class = c("purrr_error_indexed", \n  . "rlang_error", "error", "condition")))\n27. abort(message, class = error_class, parent = parent, call = error_call)\n28. signal_abort(cnd, .file)\nERROR: \x1b[1m\x1b[33mError\x1b[39m in `mutate()`:\x1b[22m\n\x1b[1m\x1b[22m\x1b[36mℹ\x1b[39m In argument: `... <- NULL`.\n\x1b[1mCaused by error in `pmap_chr()`:\x1b[22m\n\x1b[1m\x1b[22m\x1b[36mℹ\x1b[39m In index: 5174.\n\x1b[1mCaused by error in `curl::curl_fetch_memory()`:\x1b[22m\n\x1b[33m!\x1b[39m Operation was aborted by an application callback\n\n')>
Traceback (most recent call last):
  File "/Applications/anaconda3/bin/jupyter-nbconvert", line 11, in <module>
    sys.exit(main())
             ^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/jupyter_core/application.py", line 277, in launch_instance
    return super().launch_instance(argv=argv, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/traitlets/config/application.py", line 992, in launch_instance
    app.start()
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/nbconvertapp.py", line 423, in start
    self.convert_notebooks()
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/nbconvertapp.py", line 597, in convert_notebooks
    self.convert_single_notebook(notebook_filename)
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/nbconvertapp.py", line 560, in convert_single_notebook
    output, resources = self.export_single_notebook(
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/nbconvertapp.py", line 488, in export_single_notebook
    output, resources = self.exporter.from_filename(
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/exporters/exporter.py", line 189, in from_filename
    return self.from_file(f, resources=resources, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/exporters/exporter.py", line 206, in from_file
    return self.from_notebook_node(
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/exporters/notebook.py", line 35, in from_notebook_node
    nb_copy, resources = super().from_notebook_node(nb, resources, **kw)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/exporters/exporter.py", line 146, in from_notebook_node
    nb_copy, resources = self._preprocess(nb_copy, resources)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/exporters/exporter.py", line 335, in _preprocess
    nbc, resc = preprocessor(nbc, resc)
                ^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/preprocessors/base.py", line 47, in __call__
    return self.preprocess(nb, resources)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/preprocessors/execute.py", line 89, in preprocess
    self.preprocess_cell(cell, resources, index)
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbconvert/preprocessors/execute.py", line 110, in preprocess_cell
    cell = self.execute_cell(cell, index, store_history=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbclient/util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbclient/util.py", line 62, in just_run
    return loop.run_until_complete(coro)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/asyncio/base_events.py", line 640, in run_until_complete
    self.run_forever()
  File "/Applications/anaconda3/lib/python3.11/asyncio/base_events.py", line 607, in run_forever
    self._run_once()
  File "/Applications/anaconda3/lib/python3.11/asyncio/base_events.py", line 1884, in _run_once
    event_list = self._selector.select(timeout)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Applications/anaconda3/lib/python3.11/selectors.py", line 561, in select
    kev_list = self._selector.control(None, max_ev, timeout)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
KeyboardInterrupt

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbclient/client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Applications/anaconda3/lib/python3.11/site-packages/nbclient/client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
gene_info <- gene_info %>%
  mutate(upstream_region <-  pmap_chr(
      list(chromosome_name, upstream_start, upstream_end, strand), 
      fetch_sequence
  ))
------------------

[1m[33mError[39m in `mutate()`:[22m
[1m[22m[36mℹ[39m In argument: `... <- NULL`.
[1mCaused by error in `pmap_chr()`:[22m
[1m[22m[36mℹ[39m In index: 5174.
[1mCaused by error in `curl::curl_fetch_memory()`:[22m
[33m![39m Operation was aborted by an application callback
Traceback:

1. gene_info %>% mutate(upstream_region <- pmap_chr(list(chromosome_name, 
 .     upstream_start, upstream_end, strand), fetch_sequence))
2. mutate(., upstream_region <- pmap_chr(list(chromosome_name, upstream_start, 
 .     upstream_end, strand), fetch_sequence))
3. mutate.data.frame(., upstream_region <- pmap_chr(list(chromosome_name, 
 .     upstream_start, upstream_end, strand), fetch_sequence))
4. mutate_cols(.data, dplyr_quosures(...), by)
5. withCallingHandlers(for (i in seq_along(dots)) {
 .     poke_error_context(dots, i, mask = mask)
 .     context_poke("column", old_current_column)
 .     new_columns <- mutate_col(dots[[i]], data, mask, new_columns)
 . }, error = dplyr_error_handler(dots = dots, mask = mask, bullets = mutate_bullets, 
 .     error_call = error_call, error_class = "dplyr:::mutate_error"), 
 .     warning = dplyr_warning_handler(state = warnings_state, mask = mask, 
 .         error_call = error_call))
6. mutate_col(dots[[i]], data, mask, new_columns)
7. mask$eval_all_mutate(quo)
8. eval()
9. pmap_chr(list(chromosome_name, upstream_start, upstream_end, 
 .     strand), fetch_sequence)
10. pmap_("character", .l, .f, ..., .progress = .progress)
11. with_indexed_errors(i = i, names = names, error_call = .purrr_error_call, 
  .     call_with_cleanup(pmap_impl, environment(), .type, .progress, 
  .         n, names, i, call_names, call_n))
12. withCallingHandlers(expr, error = function(cnd) {
  .     if (i == 0L) {
  .     }
  .     else {
  .         message <- c(i = "In index: {i}.")
  .         if (!is.null(names) && !is.na(names[[i]]) && names[[i]] != 
  .             "") {
  .             name <- names[[i]]
  .             message <- c(message, i = "With name: {name}.")
  .         }
  .         else {
  .             name <- NULL
  .         }
  .         cli::cli_abort(message, location = i, name = name, parent = cnd, 
  .             call = error_call, class = "purrr_error_indexed")
  .     }
  . })
13. call_with_cleanup(pmap_impl, environment(), .type, .progress, 
  .     n, names, i, call_names, call_n)
14. .f(.l[[1L]][[i]], .l[[2L]][[i]], .l[[3L]][[i]], .l[[4L]][[i]], 
  .     ...)
15. GET(paste0(server, ext), content_type("text/plain"))   # at line 4 of file <text>
16. request_perform(req, hu$handle$handle)
17. request_fetch(req$output, req$url, handle)
18. request_fetch.write_memory(req$output, req$url, handle)
19. curl::curl_fetch_memory(url, handle = handle)
20. .handleSimpleError(function (cnd) 
  . {
  .     if (i == 0L) {
  .     }
  .     else {
  .         message <- c(i = "In index: {i}.")
  .         if (!is.null(names) && !is.na(names[[i]]) && names[[i]] != 
  .             "") {
  .             name <- names[[i]]
  .             message <- c(message, i = "With name: {name}.")
  .         }
  .         else {
  .             name <- NULL
  .         }
  .         cli::cli_abort(message, location = i, name = name, parent = cnd, 
  .             call = error_call, class = "purrr_error_indexed")
  .     }
  . }, "Operation was aborted by an application callback", base::quote(curl::curl_fetch_memory(url, 
  .     handle = handle)))
21. h(simpleError(msg, call))
22. cli::cli_abort(message, location = i, name = name, parent = cnd, 
  .     call = error_call, class = "purrr_error_indexed")
23. rlang::abort(message, ..., call = call, use_cli_format = TRUE, 
  .     .frame = .frame)
24. signal_abort(cnd, .file)
25. signalCondition(cnd)
26. (function (cnd) 
  . {
  .     local_error_context(dots, i = frame[[i_sym]], mask = mask)
  .     if (inherits(cnd, "dplyr:::internal_error")) {
  .         parent <- error_cnd(message = bullets(cnd))
  .     }
  .     else {
  .         parent <- cnd
  .     }
  .     message <- c(cnd_bullet_header(action), i = if (has_active_group_context(mask)) cnd_bullet_cur_group_label())
  .     abort(message, class = error_class, parent = parent, call = error_call)
  . })(structure(list(message = c(i = "In index: 5174."), trace = structure(list(
  .     call = list(IRkernel::main(), kernel$run(), handle_shell(), 
  .         executor$execute(msg), tryCatch(evaluate(request$content$code, 
  .             envir = .GlobalEnv, output_handler = oh, stop_on_error = 1L), 
  .             interrupt = function(cond) {
  .                 log_debug("Interrupt during execution")
  .                 interrupted <<- TRUE
  .             }, error = .self$handle_error), tryCatchList(expr, 
  .             classes, parentenv, handlers), tryCatchOne(tryCatchList(expr, 
  .             names[-nh], parentenv, handlers[-nh]), names[nh], 
  .             parentenv, handlers[[nh]]), doTryCatch(return(expr), 
  .             name, parentenv, handler), tryCatchList(expr, names[-nh], 
  .             parentenv, handlers[-nh]), tryCatchOne(expr, names, 
  .             parentenv, handlers[[1L]]), doTryCatch(return(expr), 
  .             name, parentenv, handler), evaluate(request$content$code, 
  .             envir = .GlobalEnv, output_handler = oh, stop_on_error = 1L), 
  .         evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
  .             debug = debug, last = i == length(out), use_try = stop_on_error != 
  .                 2L, keep_warning = keep_warning, keep_message = keep_message, 
  .             log_echo = log_echo, log_warning = log_warning, output_handler = output_handler, 
  .             include_timing = include_timing), timing_fn(handle(ev <- withCallingHandlers(withVisible(eval_with_user_handlers(expr, 
  .             envir, enclos, user_handlers)), warning = wHandler, 
  .             error = eHandler, message = mHandler))), handle(ev <- withCallingHandlers(withVisible(eval_with_user_handlers(expr, 
  .             envir, enclos, user_handlers)), warning = wHandler, 
  .             error = eHandler, message = mHandler)), try(f, silent = TRUE), 
  .         tryCatch(expr, error = function(e) {
  .             call <- conditionCall(e)
  .             if (!is.null(call)) {
  .                 if (identical(call[[1L]], quote(doTryCatch))) 
  .                   call <- sys.call(-4L)
  .                 dcall <- deparse(call, nlines = 1L)
  .                 prefix <- paste("Error in", dcall, ": ")
  .                 LONG <- 75L
  .                 sm <- strsplit(conditionMessage(e), "\n")[[1L]]
  .                 w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], 
  .                   type = "w")
  .                 if (is.na(w)) 
  .                   w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
  .                     type = "b")
  .                 if (w > LONG) 
  .                   prefix <- paste0(prefix, "\n  ")
  .             }
  .             else prefix <- "Error : "
  .             msg <- paste0(prefix, conditionMessage(e), "\n")
  .             .Internal(seterrmessage(msg[1L]))
  .             if (!silent && isTRUE(getOption("show.error.messages"))) {
  .                 cat(msg, file = outFile)
  .                 .Internal(printDeferredWarnings())
  .             }
  .             invisible(structure(msg, class = "try-error", condition = e))
  .         }), tryCatchList(expr, classes, parentenv, handlers), 
  .         tryCatchOne(expr, names, parentenv, handlers[[1L]]), 
  .         doTryCatch(return(expr), name, parentenv, handler), withCallingHandlers(withVisible(eval_with_user_handlers(expr, 
  .             envir, enclos, user_handlers)), warning = wHandler, 
  .             error = eHandler, message = mHandler), withVisible(eval_with_user_handlers(expr, 
  .             envir, enclos, user_handlers)), eval_with_user_handlers(expr, 
  .             envir, enclos, user_handlers), eval(expr, envir, 
  .             enclos), eval(expr, envir, enclos), gene_info %>% 
  .             mutate(upstream_region <- pmap_chr(list(chromosome_name, 
  .                 upstream_start, upstream_end, strand), fetch_sequence)), 
  .         mutate(., upstream_region <- pmap_chr(list(chromosome_name, 
  .             upstream_start, upstream_end, strand), fetch_sequence)), 
  .         mutate.data.frame(., upstream_region <- pmap_chr(list(chromosome_name, 
  .             upstream_start, upstream_end, strand), fetch_sequence)), 
  .         mutate_cols(.data, dplyr_quosures(...), by), withCallingHandlers(for (i in seq_along(dots)) {
  .             poke_error_context(dots, i, mask = mask)
  .             context_poke("column", old_current_column)
  .             new_columns <- mutate_col(dots[[i]], data, mask, 
  .                 new_columns)
  .         }, error = dplyr_error_handler(dots = dots, mask = mask, 
  .             bullets = mutate_bullets, error_call = error_call, 
  .             error_class = "dplyr:::mutate_error"), warning = dplyr_warning_handler(state = warnings_state, 
  .             mask = mask, error_call = error_call)), mutate_col(dots[[i]], 
  .             data, mask, new_columns), mask$eval_all_mutate(quo), 
  .         eval(), pmap_chr(list(chromosome_name, upstream_start, 
  .             upstream_end, strand), fetch_sequence), pmap_("character", 
  .             .l, .f, ..., .progress = .progress), with_indexed_errors(i = i, 
  .             names = names, error_call = .purrr_error_call, call_with_cleanup(pmap_impl, 
  .                 environment(), .type, .progress, n, names, i, 
  .                 call_names, call_n)), withCallingHandlers(expr, 
  .             error = function(cnd) {
  .                 if (i == 0L) {
  .                 }
  .                 else {
  .                   message <- c(i = "In index: {i}.")
  .                   if (!is.null(names) && !is.na(names[[i]]) && 
  .                     names[[i]] != "") {
  .                     name <- names[[i]]
  .                     message <- c(message, i = "With name: {name}.")
  .                   }
  .                   else {
  .                     name <- NULL
  .                   }
  .                   cli::cli_abort(message, location = i, name = name, 
  .                     parent = cnd, call = error_call, class = "purrr_error_indexed")
  .                 }
  .             }), call_with_cleanup(pmap_impl, environment(), .type, 
  .             .progress, n, names, i, call_names, call_n), .f(.l[[1L]][[i]], 
  .             .l[[2L]][[i]], .l[[3L]][[i]], .l[[4L]][[i]], ...), 
  .         GET(paste0(server, ext), content_type("text/plain")), 
  .         request_perform(req, hu$handle$handle), request_fetch(req$output, 
  .             req$url, handle), request_fetch.write_memory(req$output, 
  .             req$url, handle), curl::curl_fetch_memory(url, handle = handle), 
  .         .handleSimpleError(`<fn>`, "Operation was aborted by an application callback", 
  .             base::quote(curl::curl_fetch_memory(url, handle = handle))), 
  .         h(simpleError(msg, call)), cli::cli_abort(message, location = i, 
  .             name = name, parent = cnd, call = error_call, class = "purrr_error_indexed"), 
  .         rlang::abort(message, ..., call = call, use_cli_format = TRUE, 
  .             .frame = .frame)), parent = c(0L, 1L, 2L, 3L, 4L, 
  .     5L, 6L, 7L, 6L, 9L, 10L, 4L, 12L, 13L, 13L, 15L, 16L, 17L, 
  .     18L, 19L, 13L, 13L, 13L, 23L, 24L, 0L, 0L, 0L, 28L, 29L, 
  .     29L, 31L, 32L, 0L, 34L, 35L, 36L, 35L, 35L, 39L, 40L, 41L, 
  .     41L, 43L, 0L, 45L, 46L, 47L), visible = c(TRUE, TRUE, TRUE, 
  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 
  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 
  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 
  .     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 
  .     TRUE, FALSE, FALSE, FALSE, FALSE), namespace = c("IRkernel", 
  .     NA, "IRkernel", NA, "base", "base", "base", "base", "base", 
  .     "base", "base", "evaluate", "evaluate", "evaluate", "evaluate", 
  .     "base", "base", "base", "base", "base", "base", "base", "evaluate", 
  .     "base", "base", NA, "dplyr", "dplyr", "dplyr", "base", "dplyr", 
  .     NA, "dplyr", "purrr", "purrr", "purrr", "base", "purrr", 
  .     NA, "httr", "httr", "httr", "httr", "curl", "base", "purrr", 
  .     "cli", "rlang"), scope = c("::", NA, "local", NA, "::", "local", 
  .     "local", "local", "local", "local", "local", "::", ":::", 
  .     "local", "local", "::", "::", "local", "local", "local", 
  .     "::", "::", ":::", "::", "::", NA, "::", ":::", ":::", "::", 
  .     ":::", NA, "local", "::", ":::", ":::", "::", ":::", "global", 
  .     "::", ":::", ":::", ":::", "::", "::", "local", "::", "::"
  .     ), error_frame = c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
  .     TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
  .     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)), row.names = c(NA, 
  . -48L), version = 2L, class = c("rlang_trace", "rlib_trace", "tbl", 
  . "data.frame")), parent = structure(list(message = "Operation was aborted by an application callback", 
  .     call = curl::curl_fetch_memory(url, handle = handle)), class = c("simpleError", 
  . "error", "condition")), location = 5174L, name = NULL, rlang = list(
  .     inherit = TRUE), call = pmap_chr(list(chromosome_name, upstream_start, 
  .     upstream_end, strand), fetch_sequence), use_cli_format = TRUE), class = c("purrr_error_indexed", 
  . "rlang_error", "error", "condition")))
27. abort(message, class = error_class, parent = parent, call = error_call)
28. signal_abort(cnd, .file)
ERROR: [1m[33mError[39m in `mutate()`:[22m
[1m[22m[36mℹ[39m In argument: `... <- NULL`.
[1mCaused by error in `pmap_chr()`:[22m
[1m[22m[36mℹ[39m In index: 5174.
[1mCaused by error in `curl::curl_fetch_memory()`:[22m
[33m![39m Operation was aborted by an application callback


